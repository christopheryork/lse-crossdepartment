<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  font: 10px sans-serif;
}

.chord path {
  fill-opacity: .67;
  stroke: #000;
  stroke-width: .5px;
}

</style>
<body>
<script src="//d3js.org/d3.v3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/queue-async/1.0.7/queue.min.js"></script>
<script>

var labels = [];
var matrix = [];

function pushuniq(x, ys) {
  if (ys.indexOf(x) === -1) { ys.push(x) }
}

queue().defer(d3.csv, "6.1,6.3.csv")
       .defer(d3.csv, "6.2.csv")
       .defer(d3.csv, "6.4.csv")
       .await( (err, depts, research, teaching) => {
        if(err) { throw err }

        // prepare list of nodes
        research.forEach( (d) => { pushuniq(d.department1, labels); pushuniq(d.department2, labels); })
        teaching.forEach( (d) => { pushuniq(d.department1, labels); pushuniq(d.department2, labels); })

        // prepare matrix of links
        matrix = labels.map( () => labels.map( () => 0.0 ) )
        research.forEach( (d) => {
          var ds = [ d.department1, d.department2 ]
          ds.sort()
          var s = labels.indexOf(ds[0])
          var t = labels.indexOf(ds[1])
          matrix[s][t] = matrix[s][t] + +d.links
        })
        teaching.forEach( (d) => {
          var ds = [ d.department1, d.department2 ]
          ds.sort()
          ds = ds.reverse()
          var s = labels.indexOf(ds[0])
          var t = labels.indexOf(ds[1])
          matrix[s][t] = matrix[s][t] + +d.links
        })

// visualization proper

var width = 1200,
    height = 400,
    innerRadius = Math.min(width / 2.0, height) * .41,
    outerRadius = innerRadius * 1.05;

var fill = d3.scale.category20c()

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
  .append("g")
    .attr("transform", "translate(" + width / 4.0 + "," + height / 2 + ")");


function viz(elem, matrix, labels, fade) {

  function classize(s) {
    return s.replace(' ', '_')
  }

  var chord = d3.layout.chord()
      .padding(.02)
      .sortSubgroups(d3.descending)
      .matrix(matrix);

  var arc1 = d3.svg.arc().innerRadius(innerRadius).outerRadius(outerRadius)
  var arc2 = d3.svg.arc().innerRadius(outerRadius).outerRadius(outerRadius + 20)

  var dept = elem.append("g").selectAll("g.dept")
       .data(chord.groups)
     .enter()
       .append("g")
       .attr("class", "dept")

  dept.append("path")
      .style("fill", function(d) { return fill(d.index); })
      .style("stroke", function(d) { return fill(d.index); })
      .attr("d", arc1)
      .on("mouseover", fade(.1))
      .on("mouseout", fade(1))

  dept.append("text")
      .attr("transform", (d) => "translate(" + arc2.centroid(d) + ")")
      .attr("text-anchor", (d) => d.index < 12 ? "start" : "end")
      .text( (d) => labels[d.index] )

  elem.append("g")
      .attr("class", "chord")
    .selectAll("path")
      .data(chord.chords)
    .enter().append("path")
      .attr("class", (d) => classize(labels[d.target.index]) + " " + classize(labels[d.source.index]))
      .attr("d", d3.svg.chord().radius(innerRadius))
      .style("fill", function(d) { return fill(d.target.index); })
      .style("opacity", 1);
}

console.log(JSON.stringify(matrix))


viz(svg.append("g"), matrix, labels, fade)
//viz(svg.append("g").attr("transform", "translate(" + width / 2.0 + ",0)"), teaching, all_labels, fade)


// Returns an event handler for fading a given chord group.
function fade(opacity) {
  return function(g, i) {
    svg.selectAll(".chord path")
        .filter(function(d) { return d.source.index != i && d.target.index != i; })
      .transition()
        .style("opacity", opacity);
  };
}


})

</script>